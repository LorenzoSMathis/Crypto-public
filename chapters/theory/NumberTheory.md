# Number Theory

## Groups

> A group is a set with one operations $*$.

> ***Definition***: a group is a set of elements $G$ togheter with a binary operation $\circ$ that satisfies the following properties:
>
> 1. **Closure**: $\forall\ a,b \in G,\ c = a \circ b\ st\ c \in G$.
>
> 2. **Associativity**: $\forall\ a,b,c \in G,\ (a \circ b) \circ c = a \circ (b \circ c)$.
>
> 3. **Neutral element**: $\exists\ 1 \in G\ st\ \forall\ a \in G,\ a \circ 1 = 1 \circ a = a$.
>
> 4. **Inverse element**: $\forall\ a \in G,\ \exists\ a^{-1} \in G\ st\ a \circ a^{-1} = a^{-1} \circ a = 1$.
>
> 5. **Commutativity**: $\forall\ a,b \in G,\ a \circ b = b \circ a$.
>
> This means that the group is **abelian**.

### Multiplicative Group

Note that $(\mathbb{Z}_n, \times)$ id not a group, the property 4 is not satisfied. In fact the inverse of $a$ exists only if $a$ and $n$ are coprime.

Example:

$\ \ \ \ \ \ \ \ \mathbb(Z)_9 = \{1, 2, 3, 4, 5, 6, 7, 8\}$

$\ \ \ \ \ \ \ \ \circ \triangleq \times \mod 9$

The following elements are not invertible: $\{0,3,6\}$.

In fact: $gcd(0,9)=9$ and $gcd(3,9)=gcd(6,9)=3$.

> ***Definition***: we define $\mathbb{Z}_n^*$ as the set of all the invertible elements of $\mathbb{Z}_n$:
>
> $$
>   \mathbb{Z}_n^* = \{a \in \mathbb{Z}_n\ |\ gcd(a,n) = 1\}
> $$

### $\mathbb{Z}_p^*$

The group $(\mathbb{Z}_p^*)$, where $p$ is a prime number, forms a multiplicative group by removing the zero element from $\mathbb{Z}_p^* = \mathbb{Z}_p$ \ $\{0\}$.

### Finite Groups

> ***Definition***: a group is ***finite*** if the number of elements is finite.

> ***Definition***: the ***order*** of a group $|G|$ is the number of elements of the group.

### Cyclic Groups

> ***Definition***: a group is ***cyclic*** if there is $a \in G$ such that any element $b$ of $G$ is of the form $b = a \circ a \circ ... \circ a,\ n$-$times$.

> ***Definition***: the value $a$ is called ***generator*** of the group.

#### Expression of a Cyclic Group

$\mathbb{Z}_{11}^* = \{1,2,3,4,5,6,7,8,9,10\}$

$a = 3$

$3^1 = 3$

$3^2 = 9$

$3^3 = 27 \mod 11 = 5$

$3^4 = 181 \mod 11 = 4$

$3^5 = 3$

From now, the values are repeated. This means that all the values generated by $3^x, \forall x = 1,2,3,...$ are in the set $\{1,3,4,5,9\}$.

> The $ord(3) = 5$.

If we repeat the same process for $a=2$, we obtain that $ord(2) = 10$.

> ***Order of an element***: the order $ord(a)$ of an element $a$ of a group $(G, \circ)$ is the smallest positive integer $k$ such that $a^k = 1$.

> ***Theorem***: a group which contains an element $a$ with maximum order $ord(a) = |G|$ is said to be cyclic.

> ***Theorem***: if $a$ is a generator of a group $G$, then $ord(a) = |G|$.

> ***Theorem***: for every prime $p$, the group $(\mathbb{Z}_p^*, *)$ is an abelian finite cyclic group.

> ***Properties of cyclic groups***:
>
> Let $a \in G$ and $G$ be a cyclic group of order $p$.
>
> 1. $a^{|G|} = 1$.
> (Lagrange's theorem)
> 2. $ord(a) divides |G|$.
> 3. $|S_G|$ divides $|G|$, where $S_G$ is a subgroup of $G$.

## Discrete Logarithm Problem (DLP)

> ***Definition***:
>
> Given $p$ prime number, $\beta \in \mathbb{Z}_p^*$ and $\alpha$ generator of $\mathbb{Z}_p^*$. 
>
> Find $x$ such that:
>
> $\ \ \ \ \ \ \ \ \ \ \alpha^x \equiv \beta \mod p$.

## Generalized Discrete Logarithm Problem (GDLP)

Teh Discrete Logarithm is not restricted to $\mathbb{Z}_p^*$, but it can be generalized to any cyclic group.

> ***Generic Cyclic Group***
>
> $G = \{g^0, g^1, g^2, ..., g^{|G|} = 1\}$

> ***Definition***:
> Given a generic cyclic group $(G, \circ)$ and $|G| = n$. Let $g$ be a generator of $G$ and $h \in G$.
>
> Find $x$ such that:
> $\ \ \ \ \ h = g \circ g \circ ... \circ g,\ x$-$times$.
>
> In case of **additive groups**, we write: $h = x \cdot g$.
> 
> In case of **multiplicative groups**, we write: $h = g^x$.

### Groups that build a good DLP

> This groups are useful to build a cryptosystem.

1) $(\mathbb{Z}_p^*, \times)$, where $p$ is a prime number.
2) $(\mathbb{GF}(2^m)^*, \times)$.
3) Elliptic Curves.
4) Generalization of elliptic curves, ex: hyperelliptic curves.

## Fast Exponentiation

The fast exponentiation is an algorithm that allows to compute the exponentiation $\mod n$ in a fast way. The algorithm is based on the binary representation of the exponent and is called ***square-and-multiply***.

An altrernative to this algorithm is the ***Montgomery's Ladder***. The advantage of this algorithm is that it is not vulnerable to timing attacks (the time to compute $\alpha^\gamma$ is fixed).

### Some examples:

- $x^4 = ?$

    Naive approach:

    $\ \ \ \ x \cdot x = x^2$

    $\ \ \ \ x^2 \cdot x = x^3$

    $\ \ \ \ x^3 \cdot x = x^4$

    Faster approach:

    $\ \ \ \ x \cdot x = x^2$

    $\ \ \ \ x^2 \cdot x^2 = x^4$


- $x^{2^{1024}} = ?$

    Naive approach:

    $\ \ \ \ x \cdot x = x^2$

    $\ \ \ \ x^2 \cdot x = x^3$

    $\ \ \ \ ...$

    $\ \ \ \ x^{2^{1024}-1} \cdot x = x^{2^{1024}}$

    > We need to perform $2^{1024}$ multiplications: ***impossible***, suppose to write them on a blackboard... In the universe there are not enough atoms to do that.

    Faster approach:

    $\ \ \ \ x \cdot x = x^2$

    $\ \ \ \ x^2 \cdot x^2 = x^4$

    $\ \ \ \ ...$

    $\ \ \ \ x^{2^{1023}} \cdot x^{2^{2023}} = x^{2^{2024}}$

    > We need to perform $1024$ multiplications: ***possible***.

- If the exponent is not a power of 2? $x^26 = ?$

    $\ \ \ \ x \cdot x = x^2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (square)$

    $\ \ \ \ x^2 \cdot x = x^3\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (multiply)$

    $\ \ \ \ x^3 \cdot x^3 = x^6\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (square)$

    $\ \ \ \ x^6 \cdot x^6 = x^{12}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (square)$

    $\ \ \ \ x^{12} \cdot x = x^{13}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (multiply)$

    $\ \ \ \ x^{13} \cdot x^{13} = x^{26}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (square)$

    > This is the base of the square-and-multiply algorithm.

### Square-and-Multiply Algorithm

The square-and-multiply algorithm is based on the binary representation of the exponent. We scan the exponent bits from left to right and for each bit we perform:

1. The square operation (indipendently from the bit value).

2. The multiply operation if the bit is 1.

The algorithm is the following:

```python
def pow(x, e):
    ebin = bin(e)[3:]           # ignore the "0b" prefix and the first bit

    r = x

    for b in ebin:
        r = r * r               # square
        if b == '1':
            r = r * x           # multiply

    return r
```

## Euclidean Algorithm - GCD

Goal: given $r_0,\ r_1$, find $gcd(r_0,\ r_1)$.

Idea: $gcd(r_0,r_1) = gcd(r_0,r_1 \mod r_0) = gcd(r_0 \mod r_1, r_1)$

```python
# iterative version
def gcd(r0, r1):
    while r1 != 0:
        r0, r1 = r1, r0 % r1

    return r0
```

Or

```python
# recursive version
def gcd(r0, r1):
    if r1 == 0:
        return r0
    else:
        return gcd(r1, r0 % r1)
```

## Extended Euclidean Algorithm - GCD an Inverse

Goal: given $r_0,\ r_1$, find $gcd(r_0,r_1) = s \cdot r_0 + t \cdot r_1$.

Idea: starting computing the standard GCD and then express the result as a linear combination of $r_0$ and $r_1$.

### Numberic Example

| i | $r_{i-2} = q \cdot r_{i-1} + r_i$ | $r_i$                                     |
|---|-----------------------------------|-------------------------------------------|
| 2 | $973 = 3 \cdot 301 + 70$          | $r_2 = 70 = 1 \cdot 973 + (-3) \cdot 301$ |
| 3 | $301 = 4 \cdot 70 \ + 21$         | $r_3 = 21 = 1 \cdot 301 + (-4) \cdot 70 = \\ \ \ \ \ \ \ \ \ \ 1 \cdot 301 + (-4) \cdot (973 - 3 \cdot 301) = \\ \ \ \ \ \ \ \ \ \ 13 \cdot 301 - 4 \cdot 973 $|
| 4 | $70 = 3 \cdot 21 + 7$             | $r_4 = 7 = 1 \cdot 70 + (-3) \cdot 21 = \\ \ \ \ \ \ \ \ \ \ 1 \cdot (973 - 3 \cdot 301) + (-3) \cdot (13 \cdot 301 - 4 \cdot 973) = \\ \ \ \ \ \ \ \ \ \ 13 \cdot 973 - 42 \cdot 301$ |
| 5 | $21 = 3 \cdot 7 + 0$              | $r_5 = 0\ STOP$ |

The result is $gcd(973,301) = 7 = 13 \cdot 973 - 42 \cdot 301$.

### The inverse

The inverse is $a^{-1}\ st\ a \cdot a^{-1} \equiv 1 \mod n$.

We can write:

$gcd(n,a) = 1 \equiv s \cdot n + t \cdot a \mod n \equiv t \cdot a \mod n\ \ \rightarrow \ \ t \cdot a \equiv 1 \mod n\ \ \rightarrow\ \ t\ is\ a^{-1}$

Remember: $s \cdot n \mod n = 0 \mod n$.

### Python

```python
def egcd(n,a):
    if a == 0:
        return n, 1, 0
    else:
        g, s, t = egcd(a, n % a)
        return g, t, s - (n // a) * t

def inverse(a, n):
    g, s, t = egcd(n, a)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return t
```

## Fermat's Little Theorem

> ***Theorem***: let $p$ be a prime number and $a \in \mathbb{Z}_p^*$, then: 
>
> $a^p \equiv a \mod p$ 

## Euler's $\phi(m)$ Function

> ***Definition***: let $m$ be a positive integer, then $\phi(m)$ is the **number of positive integers less than $m$ that are coprime with $m$**.

> ***Theorem***: let $m$ be a positive integer with the following canonical form (factorization):
>
> $\ \ \ \ \ m = \prod_{i=1}^n p_i^{e_i}$
>
> Where $p_i$ are prime numbers and $e_i$ are positive integers. Then:
>
> $\ \ \ \ \ \phi(m) = \prod_{i=1}^n(p_i^{e_1} - p_i^{e_i-1})$

## Euler's Theorem

> ***Theorem***: let $m$ be a positive integer and $a \in \mathbb{Z}_m^*$, then:
>
> $a^{\phi(m)} \equiv 1 \mod m$
>
> If $m$ is a prime number, then $\phi(m) = m - 1$ and the theorem becomes:
>
> $a^{m-1} \equiv 1 \mod m$ 

## Quadratic Residues - Solving $x^2 = r \mod n$

> ***Euler's Criterion***: let $p$ be a prime number and and $r$ an integer non divisible by $p$, then $r$ is a quadratic residue $\mod p$ if and only if:
>
> $r^{\frac{p-1}{2}} \equiv 1 \mod p$

Some explanation:

For the [Fermat's Little Theorem](#fermats-little-theorem), we can say:

$x^{p-1} \equiv 1 mod p$

That can be written as:

$x^{p-1} - 1 \equiv 0 \mod p$

Now $p$ is a prime number, excluting $p=2$, $p$ is odd, then $p-1$ is even. This means that we can write:

$(x^{\frac{p-1}{2}} - 1)(x^{\frac{p-1}{2}} + 1) \equiv 0 \mod p$

This is $\equiv 0 \mod p$, so we can say that it is a multiple of $p$. From this we can say that one of two parenthesis is a multiple of $p$. So:

$x^{\frac{p-1}{2}} - 1 \equiv 0 \mod p$

or 

$x^{\frac{p-1}{2}} + 1 \equiv 0 \mod p$

By using index calculus, we can say that:

If $x^{\frac{p-1}{2}} \equiv 1 \mod p$, then $x$ is a quadratic residue $\mod p$.

Otherwise, if $x^{\frac{p-1}{2}} \equiv -1 \mod p$, then $x$ is a quadratic non-residue $\mod p$.

To calculate the quadratic residue, we can use the [Euler's Criterion](#eulers-criterion).

## Groups of Quadratic Residues

1) The set $G$ of quadratic residues $\mod n$ is a subgroup of $\mathbb{Z}_n^*$.

2) In case $n$ is a prime number and $n = 2p + 1$ where $p$ is also a prime number, then $G$ is a cyclic group of order $p$.

3) If $r$ is a quadratic residue $p \equiv 3 \mod 4$, then $r^{\frac{p+1}{4}}$ is a square root of $r$.

4) If $r$ is a quadratic residue $p \equiv 1 \mod 4$, then there is an efficient algorithm to compute the square roots of $r$ (Algorithm of Tonelli-Shanks).

## Cipolla's Algorithm

Let $r$ be a quadratic residue $\mod p$.

To find a square root $u \in \mathbb{Z}_p^*$ of $r$, find $s \in \mathbb{Z}_p^*$ such that $s^2 - r$ is not a quadratic residue $\mod p$. Then:

$$
A = \begin{bmatrix}
        s & s6 2-r \\
        1 & s
    \end{bmatrix}
$$

and compute $u$ as:

$$
A^{\frac{p+1}{2}} = \begin{bmatrix}
        u & 0 \\
        0 & u
    \end{bmatrix}
$$

### Python Implementation

```python

def cipolla(r, p):
    if p % 4 == 3:
        u = pow(r, (p + 1) // 4, p)
        return u
    elif p % 4 == 1:
        s = 0
        while True:
            s = random.randint(1, p - 1)
            if pow(s, 2, p) != pow(r, (p - 1) // 2, p):
                break

        a = (s, (s ** 2 - r) % p)
        b = (1, s)

        for i in range((p + 1) // 2):
            a, b = ((a[0] * b[0] + a[1] * b[1]) % p, (a[0] * b[1] + a[1] * b[0]) % p), ((b[0] ** 2 + b[1] ** 2) % p, (2 * b[0] * b[1]) % p)

        return a[0]
    else:
        raise Exception('p must be prime')
```

## Chinese Remainder Theorem - CRT

Let $p,q$ be two coprime integers, then:

$\ \ \ \ \ x \equiv a \mod p$

$\ \ \ \ \ x \equiv b \mod q$

The equation system has a unique solution $x \mod pq$.

```python
def crt(a, b, p, q):
    n = p * q
    m1 = inverse(q, p)
    m2 = inverse(p, q)
    return (a * m1 * q + b * m2 * p) % n
```

```python
# A = [a,b, ...] residues
# N = [p,q, ...] moduli
def crt(A, N):
    n = 1
    for ni in N:
        n *= ni

    x = 0
    for i in range(len(A)):
        x += A[i] * n // N[i] * inverse(n // N[i], N[i])

    return x % n
```

## Rabbin-Miller Primality Test

Let $n$ an odd number. Set $n-1 = 2^s \cdot d$ with $d$ odd.

If $n$ prime and $a \ne 0 \mod n$, then:

1. $a^d \equiv 1 \mod n$ or

2. $a^{2^r \cdot d} \equiv -1 \mod n$ for some $r \in \{0,1,...,s-1\}$

```python
def is_prime(n, k=10):
    if n == 2:              # Easy case -> 2 is prime
        return True
    elif n % 2 == 0:        # Even number -> not prime
        return False

    s = 0
    d = n - 1
    while d % 2 == 0:
        s += 1
        d //= 2

    for i in range(k):
        a = random.randint(2, n - 1)
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue

        for j in range(s - 1):
            x = pow(x, 2, n)
            if x == 1:
                return False
            elif x == n - 1:
                break
        else:
            return False

    return True
```

## Prime Number Theorem

The total nmber of prime numbers less than $n$ is approximately $\frac{n}{\ln n}$.

## Prime Number Generation, where $p$ is a prime number

Pick a $n$ bits random number $X \in [2^{n-1}, 2^n - 1]$.

Test if it is prime by using the [Rabbin-Miller Primality Test](#rabbin-miller-primality-test).

If it is not prime, repeat the process.

> For the [Prime Number Theorem](#prime-number-theorem), the probability that $X$ is prime can be approximated to $\frac{2^{n-1}}{n}$.
>
> The failing probability fater $t$ trials is $(1 - \frac{1}{n})^t$.